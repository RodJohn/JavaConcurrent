

Java的并发采用的是共享内存模型


同步是指程序中用于控制不同线程间操作发生相对顺序的机制


内存可见性


Java内存模型

  本地内存  内存可见性  写缓冲区

  JMM决定一个线程对共享变量的写入何时对另一个线程可见
  JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。
  happens-before
  

重排序

  作用 写缓冲区
  影响
  
  数据依赖性
  as-if-serial

  多线程 数据竞争
  
  禁止重排序 内存屏障 


同步的多线程

  顺序一致性




锁


volatile


final








# volatile

对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

内存

  当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存
  当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

  线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息


实现原理

  禁止重排序
  从编译器重排序规则和处理器内存屏障插入策略

volatile和锁

  内存语义
  
  

# 锁

  锁可以让临界区互斥执行  顺序执行

内存含义



  当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中
  线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量

  释放锁的线程。通过主内存向向获取同一个锁的线程发送消息


锁释放-获取的内存语义的实现 和 volatile











