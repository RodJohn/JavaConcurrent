
原子（atomic）本意是“不能被进一步分割的最小粒子”，
而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。



# 处理器如何实现原子

第一个机制是通过总线锁保证原子性。

第二个机制是通过缓存锁定来保证原子性

交换指令XADD、CMPXCHG

# .Java如何实现原子操作

CAS

JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本
思路就是循环进行CAS操作直到成功为止，

CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。

1）ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化
则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它
的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面
追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。从
Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个
类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是
否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。


2）循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如
果JVM能支持处理器提供的pause指令，

3）只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循
环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子
性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来
操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，
JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对
象里来进行CAS操作



