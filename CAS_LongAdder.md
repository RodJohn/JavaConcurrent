
# LongAdder 简单介绍

前面讲过 AtomicLong 通过 CAS 提供了非阻塞的原子性操作，相 使用阻塞算法的
同步器来说它的性能己经很好了，但是 JDK 开发组并不满足于此 使用 AtomicLong 时，
在高并发 大量线程会同时去竞争更新 个原子变量，但是由于同时只有 个线程的
CAS 操作会成功，这就造成了大 线程竞争失败后，会通过无限循环不断进行自旋尝试
CAS 操作， 这会白白浪费 PU 资源。
因此 JDK 新增了 个原子性递增或者递减类 LongAdder 用来克服在高并发下使用
AtomicLong 的缺 既然 AtomicLong 的性能瓶颈是由于过 线程同时去竞争 个变量的
更新而产生的，那么如果把一个变 分解为多个变量，让同样多的线程去竞争多个资源
是不是就解决了性能问题？是的， LongAdd 就是这个思路 面通过图来理解两者设计
的不同之处，


使用 AtomicLong 时，是多个线程同时竞争同 个原子变量。


# 原理

4-2 示，使用 LongAdder 时，则是在内部维护多个 Ce ll 变量，每个 ell 里面
个初始值为 long 型变 ，这样，在同等并发量的情况下，争夺单个变量更新操
作的线程量会减少，这变相地减少了 争夺共享资源的并发量。另 外，多个线程在争
Cell 原子变量时如果失败了 它并不是在当前 Ce ll 变量上一直自旋 CAS 重试，而是
试在其他 Ce ll 变量上进行 CAS 尝试 ，这个改变增加了当前线程重试 CAS 成功的可能性
最后，在获取 LongAdder 前值时， 把所有 Cell 变量 value 累加后再加上 base 返回的
LongAdder 维护了 个延迟初始化的原子性更新数组（默认情况 Cell 数组是 null
个基值变量 bas 由于 Ce ll 占用的内存是相对比较大的，所以一开始并不创建它，
是在需要时创建，也就是惰性加载。
当一开始判断 Cell 数组是 null 并且并发线程较少时，所有 加操作都是对 base
量进行的 保持 Ce ll 数组的大小为 的 N 次方，在初始化时 Cell 数组中的 ell 元素
，数组 面的变量实体是 Cell 类型。 Cell 类型是 tomicLong 一个改进，用来减少
缓存的争用，也就是解决伪共享问题
对于大多数孤立的多个原子操作进行字节填充是浪费的，因为原子性操作都是无规律
地分散在内存中的 （也就是说多个原子性变量的内存地址是不连续的）， 原子变量被
放入同 存行的可能性很小 但是原子性数组元素的内存地址是连续的，所以数组内
个元素能经常共享缓存行，因此这 使用 sun.misc.Contended 注解对 Cell 进行
填充，这防止了 数组中多个元素共享一个缓存行，在性能上是一个提升










